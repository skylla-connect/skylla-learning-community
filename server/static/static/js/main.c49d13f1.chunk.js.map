{"version":3,"sources":["App/firebase.js","App/session/context.js","App/components.js","App/session/withAuthetication.js","App.js","serviceWorker.js","index.js","register-sw.js"],"names":["firebaseConfig","apiKey","process","authDomain","databaseURL","projectId","storageBucket","messagingSenderId","appId","Firebase","requestFirebaseNotificationPermission","Promise","resolve","messaging","getToken","then","firebaseToken","catch","err","console","log","onMessageListener","onMessage","payload","doCreateUserWithEmailAndPassword","email","password","auth","createUserWithEmailAndPassword","doSignInWithEmailAndPassword","signInWithEmailAndPassword","doSignOut","signOut","doPasswordReset","sendPasswordResetEmail","doCreateNewUser","userCredentials","a","db","doc","userId","set","doCreateNewTrainer","doGetUserAdmin","get","doGetUserTrainer","doGetUserTrainee","doGetMessages","roomID","startPos","endPos","undefined","collection","orderBy","limit","snapshot","result","docs","map","push","data","doPushMessage","roomId","add","doSetTokens","this","id","doGetTokens","doGetAdmins","app","initializeApp","firestore","FirebaseContext","React","createContext","withFirebase","Component","props","Consumer","firebase","AuthUserContext","spin","keyframes","transform","Centered","styled","div","display","flexDirection","alignItems","justifyContent","width","height","Spinner","css","animation","aria-label","FullPageSpinner","fontSize","FormGroup","withAuthentication","WithAuthentication","state","authUser","isSettled","listener","onAuthStateChanged","setState","Provider","value","loadAuthenticatedApp","AuthenticatedApp","lazy","UnauthenticatedApp","useUser","context","useContext","Error","withAuthetication","useState","firstAttemptFinished","setFirstAttemptFinished","user","useEffect","useLayoutEffect","Suspense","fallback","Boolean","window","location","hostname","match","ReactDOM","render","App","document","getElementById","navigator","serviceWorker","register","registration","scope"],"mappings":"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","file":"static/js/main.c49d13f1.chunk.js","sourcesContent":["import React from 'react';\r\nimport app from 'firebase/app';\r\nimport 'firebase/auth';\r\nimport 'firebase/firestore';\r\nimport 'firebase/messaging';\r\n\r\n// For Firebase JS SDK v7.20.0 and later, measurementId is optional\r\n\r\nconst firebaseConfig = {\r\n    apiKey: process.env.REACT_APP_API_KEY,\r\n    authDomain: process.env.REACT_APP_AUTH_DOMAIN,\r\n    databaseURL: process.env.REACT_APP_DATABASE_URL,\r\n    projectId: process.env.REACT_APP_PROJECT_ID,\r\n    storageBucket: process.env.REACT_APP_STORAGE_BUCKET,\r\n    messagingSenderId: process.env.REACT_APP_MESSAGING_SENDER_ID,\r\n    appId: process.env.REACT_APP_APA_ID,\r\n};\r\n\r\nclass Firebase {\r\n    constructor() {\r\n        app.initializeApp(firebaseConfig);\r\n        this.auth = app.auth();\r\n        this.db = app.firestore()\r\n        this.messaging = app.messaging()\r\n\r\n        // this.messaging.setBackgroundMessageHandler(function(payload) {\r\n        //     console.log('[firebase-messaging-sw.js] Received background message ', payload);\r\n        //     const notificationTitle = payload.data.title;\r\n        //     const notificationOptions = {\r\n        //       body: payload.data.body,\r\n        //       icon: '/firebase-logo.png'\r\n        //     };\r\n        //     return self.registration.showNotification(notificationTitle,\r\n        //       notificationOptions);\r\n        //   });\r\n          \r\n        //   self.addEventListener('notificationclick', event => {\r\n        //     console.log(event)\r\n        //     return event;\r\n        //   });\r\n    }\r\n    // notification\r\n    requestFirebaseNotificationPermission = () =>\r\n    new Promise((resolve) => {\r\n        this.messaging.getToken()\r\n      .then((firebaseToken) => {\r\n        resolve(firebaseToken);\r\n      })\r\n      .catch((err) => {\r\n        console.log(err);\r\n      });\r\n    });\r\n    onMessageListener = () =>\r\n    new Promise((resolve) => {\r\n        this.messaging.onMessage((payload) => {\r\n            console.log(payload);\r\n        resolve(payload);\r\n        });\r\n    });\r\n    // onBackgroundMessageHandler = () => \r\n    // new Promise((resolve) => {\r\n    //     this.messaging.setBackgroundMessageHandler(function(payload) {\r\n    //         resolve(payload)\r\n    //     });\r\n    // })\r\n    // sendNotificationToClient = (tokens, notification) => {\r\n    //     // Send a message to the devices corresponding to the provided\r\n    //     // registration tokens.\r\n    //     this.messaging\r\n    //       .sendMulticast({ tokens, notification })\r\n    //       .then(response => {\r\n    //         // Response is an object of the form { responses: [] }\r\n    //         const successes = response.responses.filter(r => r.success === true)\r\n    //           .length;\r\n    //         const failures = response.responses.filter(r => r.success === false)\r\n    //           .length;\r\n    //         console.log(\r\n    //           'Notifications sent:',\r\n    //           `${successes} successful, ${failures} failed`\r\n    //         );\r\n    //       })\r\n    //       .catch(error => {\r\n    //         console.log('Error sending message:', error);\r\n    //       });\r\n    //   };\r\n      \r\n    // *** Auth API ***\r\n    doCreateUserWithEmailAndPassword = (email, password) =>\r\n    this.auth.createUserWithEmailAndPassword(email, password);\r\n\r\n    doSignInWithEmailAndPassword = (email, password) =>\r\n    this.auth.signInWithEmailAndPassword(email, password);\r\n\r\n    doSignOut = () => this.auth.signOut();\r\n\r\n    doPasswordReset = email => this.auth.sendPasswordResetEmail(email);\r\n\r\n    doCreateNewUser = async (userCredentials) => \r\n    await this.db.doc(`/users/trainee/users/${userCredentials.userId}`).set(userCredentials);\r\n\r\n    // Create a new trainer\r\n    doCreateNewTrainer = async (userCredentials) => \r\n    await this.db.doc(`/users/trainer/sys_trainers/${userCredentials.userId}`).set(userCredentials);\r\n\r\n    doGetUserAdmin = (userId) => {\r\n        return this.db.doc(`/users/admin/users/${userId}`)\r\n        .get()\r\n    }\r\n    doGetUserTrainer = (userId) => {\r\n        return this.db.doc(`/users/trainer/users/${userId}`)\r\n        .get() \r\n    }\r\n    doGetUserTrainee = (userId) => {\r\n        return this.db.doc(`/users/trainee/users/${userId}`)\r\n        .get() \r\n    }\r\n    // chat\r\n    doGetMessages = async (roomID, startPos, endPos) => {\r\n        if (endPos === undefined) {\r\n            if (startPos > -10 && startPos < 0)\r\n                endPos = -1;\r\n            else\r\n                endPos = startPos + 9\r\n        }\r\n        return await this.db.collection(`/messages/${roomID}/dialogue`)\r\n        .orderBy(\"createdAt\", 'desc').limit(endPos).get()\r\n        .then(snapshot => {\r\n            let result = [];\r\n            // Loop through the list, parsing each item into an object\r\n            snapshot.docs.map(doc => {\r\n                result.push(doc.data());\r\n            })\r\n            return result;\r\n        }).catch(err => console.log(err));\r\n    }\r\n    doPushMessage = async (data) => {\r\n        await this.db.collection(`/messages/${data.roomId}/dialogue`).add(data);\r\n    } \r\n    doSetTokens = async function(data) {\r\n        await this.db.doc(`/users/admin/tokens/${data.id}`).set(data)\r\n    } \r\n    doGetTokens = async () => {\r\n        return await this.db.collection(`/users/admin/tokens`).get()\r\n    }  \r\n    doGetAdmins = () => this.db.collection(`/users/admin/users`).get()   \r\n}\r\nexport default Firebase;\r\nconst FirebaseContext = React.createContext(null);\r\n\r\nconst withFirebase = Component => props => (\r\n    <FirebaseContext.Consumer>\r\n        {firebase => <Component {...props} firebase={firebase} />}\r\n    </FirebaseContext.Consumer>\r\n    );\r\nexport { FirebaseContext, withFirebase };","import React from 'react';\r\n\r\nconst AuthUserContext = React.createContext(null);\r\nexport default AuthUserContext;\r\n","/** @jsx jsx */\r\nimport {jsx} from '@emotion/core'\r\n\r\nimport {keyframes} from '@emotion/core'\r\nimport styled from '@emotion/styled'\r\nimport {FaSpinner} from 'react-icons/fa'\r\n\r\nconst spin = keyframes({\r\n  '0%': {transform: 'rotate(0deg)'},\r\n  '100%': {transform: 'rotate(360deg)'},\r\n})\r\n\r\nexport const Centered = styled.div({\r\n  display: 'flex',\r\n  flexDirection: 'column',\r\n  alignItems: 'center',\r\n  justifyContent: 'center',\r\n  width: '100%',\r\n  height: '100vh',\r\n})\r\n\r\n\r\nexport function Spinner(props) {\r\n  return (\r\n    <FaSpinner\r\n      css={{animation: `${spin} 1s linear infinite`}}\r\n      aria-label=\"loading\"\r\n      {...props}\r\n    />\r\n  )\r\n}\r\n\r\nexport function FullPageSpinner() {\r\n  return (\r\n    <Centered>\r\n    <div css={{\r\n      fontSize: '4em'}}>\r\n      <Spinner />\r\n    </div>\r\n    </Centered>\r\n  )\r\n}\r\n// *** input //\r\n\r\nexport const FormGroup = styled.div({\r\n    display: 'flex',\r\n    flexDirection: 'column',\r\n  })\r\n","import React from 'react';\r\nimport AuthContext from './context';\r\nimport { withFirebase } from '../firebase';\r\nconst withAuthentication = Component => {\r\n\r\n    class WithAuthentication extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n        authUser: null,\r\n        isSettled: false,\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.listener = this.props.firebase.auth.onAuthStateChanged(\r\n        authUser => {\r\n        authUser\r\n        ? this.setState({ authUser: authUser, isSettled: true })\r\n        : this.setState({ authUser: null, isSettled: true });\r\n        },\r\n        );\r\n    }\r\n    componentWillUnmount() {\r\n        this.listener();\r\n    }\r\n    render() {\r\n        return (\r\n        <AuthContext.Provider value={{...this.state}}>\r\n            <Component {...this.props} />\r\n        </AuthContext.Provider>\r\n        );\r\n        }\r\n    }\r\n    return withFirebase(WithAuthentication);\r\n}\r\nexport default withAuthentication;\r\n","import React from 'react';\r\nimport {FullPageSpinner} from './App/components';\r\nimport {  } from \"recompose\";\r\nimport withAuthetication from \"./App/session/withAuthetication\";\r\nimport AuthUserContext from \"./App/session/context\";\r\n// import LiveSupport from '../src/LiveSupport/LiveSupport'\r\n\r\nconst loadAuthenticatedApp = () => import('./authenticated-app')\r\nconst AuthenticatedApp = React.lazy(loadAuthenticatedApp)\r\nconst UnauthenticatedApp = React.lazy(() => import('./unauthenticated-app'))\r\n\r\nexport function useUser() {\r\n  const context = React.useContext(AuthUserContext);\r\n  if (context === undefined) {\r\n    throw new Error(`useUser must be used within a UserProvider`)\r\n  }\r\n  return context\r\n}\r\nconst App = () => {\r\n  const [firstAttemptFinished, setFirstAttemptFinished] = React.useState(false);\r\n  const { isSettled, authUser } = useUser();\r\n\r\n  const user = authUser;\r\n\r\n  // pre-load the authenticated side in the background while the user's\r\n  // filling out the login form.\r\n  React.useEffect(() => {\r\n    loadAuthenticatedApp()\r\n  }, [])\r\n  React.useLayoutEffect(() => {\r\n    if (isSettled) {\r\n      setFirstAttemptFinished(true)\r\n    }\r\n  }, [isSettled])\r\n\r\n  if (!firstAttemptFinished) {\r\n      return <FullPageSpinner />\r\n  }\r\n  return (\r\n    <React.Suspense fallback={<FullPageSpinner />}>\r\n        {user ? <AuthenticatedApp /> : <UnauthenticatedApp />}\r\n    </React.Suspense>\r\n    \r\n  )\r\n}\r\n\r\nexport default withAuthetication(App);\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\n// import './index.css';\r\n// import Container from './App/index';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport Firebase, { FirebaseContext } from './App/firebase';\r\nimport './App/bootstrap';\r\nimport { registerServiceWorker } from './register-sw'\r\n\r\nReactDOM.render(\r\n  <FirebaseContext.Provider value={new Firebase()}>\r\n    <App />\r\n  </FirebaseContext.Provider>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your App to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\n// serviceWorker.register();\r\n\r\nregisterServiceWorker();\r\n","const registerServiceWorker = () => {\r\n  if (\"serviceWorker\" in navigator) {\r\n    navigator.serviceWorker\r\n      .register(\"./firebase-messaging-sw.js\")\r\n      .then(function(registration) {\r\n        console.log(\"Registration successful, scope is:\", registration.scope);\r\n\r\n      })\r\n      .catch(function(err) {\r\n        console.log(\"Service worker registration failed, error:\", err);\r\n      });\r\n  }\r\n};\r\n\r\nexport { registerServiceWorker };"],"sourceRoot":""}